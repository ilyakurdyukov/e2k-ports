From 154a911759962db322cbe5d2fb6af2ce4b39c402 Mon Sep 17 00:00:00 2001
From: Ilya Kurdyukov <jpegqs@gmail.com>
Date: Sat, 11 Sep 2021 11:17:06 +0700
Subject: [PATCH] webkitgtk-2.32.3 e2k support

---
 Source/JavaScriptCore/heap/Heap.cpp           | 49 ++++++++++---------
 .../llint/LLIntOffsetsExtractor.cpp           |  8 +++
 Source/ThirdParty/ANGLE/src/common/mathutil.h |  4 +-
 Source/ThirdParty/ANGLE/src/common/platform.h |  2 +-
 Source/WTF/wtf/OptionSet.h                    |  7 +++
 Source/WTF/wtf/PlatformCPU.h                  |  4 ++
 Source/WTF/wtf/PlatformEnable.h               |  2 +-
 Source/WTF/wtf/dtoa/utils.h                   |  1 +
 .../WTF/wtf/text/IntegerToStringConversion.h  |  3 ++
 .../bindings/scripts/CodeGeneratorJS.pm       |  4 ++
 Source/WebCore/platform/graphics/ColorTypes.h |  6 +++
 Source/WebCore/rendering/style/GridArea.h     |  3 ++
 Source/WebKit/UIProcess/WebPageProxy.cpp      | 12 ++---
 13 files changed, 73 insertions(+), 32 deletions(-)

diff --git a/Source/JavaScriptCore/heap/Heap.cpp b/Source/JavaScriptCore/heap/Heap.cpp
index 29749d84..31c051fd 100644
--- a/Source/JavaScriptCore/heap/Heap.cpp
+++ b/Source/JavaScriptCore/heap/Heap.cpp
@@ -2846,33 +2846,36 @@ void Heap::addCoreConstraints()
         })),
         ConstraintVolatility::GreyedByMarking);
     
+#define EDG_FIX(Visitor) \
+        ([] (Visitor& visitor) { \
+            VM& vm = visitor.vm(); \
+            \
+            /* The `visitor2` argument is strangely named because the WinCairo port */ \
+            /* gets confused  and thinks we're trying to capture the outer visitor */ \
+            /* arg here. Giving it a unique name works around this issue. */ \
+            auto callOutputConstraint = [] (Visitor& visitor2, HeapCell* heapCell, HeapCell::Kind) { \
+                SetRootMarkReasonScope rootScope(visitor2, RootMarkReason::Output); \
+                VM& vm = visitor2.vm(); \
+                JSCell* cell = static_cast<JSCell*>(heapCell); \
+                cell->methodTable(vm)->visitOutputConstraints(cell, visitor2); \
+            }; \
+            \
+            auto add = [&] (auto& set) { \
+                RefPtr<SharedTask<void(Visitor&)>> task = set.template forEachMarkedCellInParallel<Visitor>(callOutputConstraint); \
+                visitor.addParallelConstraintTask(task); \
+            }; \
+            \
+            add(vm.executableToCodeBlockEdgesWithConstraints); \
+            if (vm.m_weakMapSpace) \
+                add(*vm.m_weakMapSpace); \
+        })
+
     m_constraintSet->add(
         "O", "Output",
-        MAKE_MARKING_CONSTRAINT_EXECUTOR_PAIR(([] (auto& visitor) {
-            using Visitor = decltype(visitor);
-            VM& vm = visitor.vm();
-
-            // The `visitor2` argument is strangely named because the WinCairo port
-            // gets confused  and thinks we're trying to capture the outer visitor
-            // arg here. Giving it a unique name works around this issue.
-            auto callOutputConstraint = [] (Visitor& visitor2, HeapCell* heapCell, HeapCell::Kind) {
-                SetRootMarkReasonScope rootScope(visitor2, RootMarkReason::Output);
-                VM& vm = visitor2.vm();
-                JSCell* cell = static_cast<JSCell*>(heapCell);
-                cell->methodTable(vm)->visitOutputConstraints(cell, visitor2);
-            };
-            
-            auto add = [&] (auto& set) {
-                RefPtr<SharedTask<void(Visitor&)>> task = set.template forEachMarkedCellInParallel<Visitor>(callOutputConstraint);
-                visitor.addParallelConstraintTask(task);
-            };
-            
-            add(vm.executableToCodeBlockEdgesWithConstraints);
-            if (vm.m_weakMapSpace)
-                add(*vm.m_weakMapSpace);
-        })),
+        MarkingConstraintExecutorPair(EDG_FIX(AbstractSlotVisitor), EDG_FIX(SlotVisitor)),
         ConstraintVolatility::GreyedByMarking,
         ConstraintParallelism::Parallel);
+#undef EDG_FIX
     
 #if ENABLE(DFG_JIT)
     if (Options::useJIT()) {
diff --git a/Source/JavaScriptCore/llint/LLIntOffsetsExtractor.cpp b/Source/JavaScriptCore/llint/LLIntOffsetsExtractor.cpp
index c8c26152..b026fcb3 100644
--- a/Source/JavaScriptCore/llint/LLIntOffsetsExtractor.cpp
+++ b/Source/JavaScriptCore/llint/LLIntOffsetsExtractor.cpp
@@ -80,6 +80,14 @@
 
 namespace JSC {
 
+#ifdef __e2k__
+// linker doesn't remove dead code
+const unsigned opcodeLengths[] = { 0 };
+const unsigned wasmOpcodeLengths[] = { 0 };
+const char* const opcodeNames[] = { nullptr };
+const char* const wasmOpcodeNames[] = { nullptr };
+#endif
+
 #define OFFLINE_ASM_OFFSETOF(clazz, field) (static_cast<unsigned>(OBJECT_OFFSETOF(clazz, field)))
 
 class LLIntOffsetsExtractor {
diff --git a/Source/ThirdParty/ANGLE/src/common/mathutil.h b/Source/ThirdParty/ANGLE/src/common/mathutil.h
index 1d73bbff..5c5f832f 100644
--- a/Source/ThirdParty/ANGLE/src/common/mathutil.h
+++ b/Source/ThirdParty/ANGLE/src/common/mathutil.h
@@ -145,7 +145,9 @@ inline unsigned int unorm(float x)
 
 inline bool supportsSSE2()
 {
-#if defined(ANGLE_USE_SSE)
+#if defined(__e2k__)
+    return true;
+#elif defined(ANGLE_USE_SSE)
     static bool checked  = false;
     static bool supports = false;
 
diff --git a/Source/ThirdParty/ANGLE/src/common/platform.h b/Source/ThirdParty/ANGLE/src/common/platform.h
index 41f3cf4f..a61d3448 100644
--- a/Source/ThirdParty/ANGLE/src/common/platform.h
+++ b/Source/ThirdParty/ANGLE/src/common/platform.h
@@ -89,7 +89,7 @@
 #if defined(_MSC_VER) && !defined(_M_ARM) && !defined(_M_ARM64)
 #    include <intrin.h>
 #    define ANGLE_USE_SSE
-#elif defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__))
+#elif defined(__GNUC__) && (defined(__x86_64__) || defined(__i386__) || defined(__e2k__))
 #    include <x86intrin.h>
 #    define ANGLE_USE_SSE
 #endif
diff --git a/Source/WTF/wtf/OptionSet.h b/Source/WTF/wtf/OptionSet.h
index 36bcc04d..54709d16 100644
--- a/Source/WTF/wtf/OptionSet.h
+++ b/Source/WTF/wtf/OptionSet.h
@@ -241,6 +241,13 @@ public:
         return fromRaw(lhs.m_storage ^ rhs.m_storage);
     }
 
+#ifdef __EDG__
+    constexpr OptionSet operator|(E e) const
+    {
+        return fromRaw(m_storage | static_cast<StorageType>(e));
+    }
+#endif
+
 private:
     enum InitializationTag { FromRawValue };
     constexpr OptionSet(E e, InitializationTag)
diff --git a/Source/WTF/wtf/PlatformCPU.h b/Source/WTF/wtf/PlatformCPU.h
index 0e711de3..a853107a 100644
--- a/Source/WTF/wtf/PlatformCPU.h
+++ b/Source/WTF/wtf/PlatformCPU.h
@@ -112,6 +112,10 @@
 #define WTF_CPU_KNOWN 1
 #endif
 
+#if defined(__SSE2__) && defined(__e2k__)
+#define WTF_CPU_X86_SSE2 1
+#endif
+
 /* CPU(ARM64) */
 #if defined(__arm64__) || defined(__aarch64__)
 #define WTF_CPU_ARM64 1
diff --git a/Source/WTF/wtf/PlatformEnable.h b/Source/WTF/wtf/PlatformEnable.h
index 19a8e476..7097813e 100644
--- a/Source/WTF/wtf/PlatformEnable.h
+++ b/Source/WTF/wtf/PlatformEnable.h
@@ -820,7 +820,7 @@
 #define ENABLE_GC_VALIDATION 1
 #endif
 
-#if !defined(ENABLE_BINDING_INTEGRITY) && !OS(WINDOWS)
+#if !defined(ENABLE_BINDING_INTEGRITY) && !OS(WINDOWS) && !defined(__EDG__)
 #define ENABLE_BINDING_INTEGRITY 1
 #endif
 
diff --git a/Source/WTF/wtf/dtoa/utils.h b/Source/WTF/wtf/dtoa/utils.h
index 96d5bd7b..298f44a6 100644
--- a/Source/WTF/wtf/dtoa/utils.h
+++ b/Source/WTF/wtf/dtoa/utils.h
@@ -83,6 +83,7 @@ int main(int argc, char** argv) {
     defined(__ARMEL__) || defined(__avr32__) || defined(_M_ARM) || defined(_M_ARM64) || \
     defined(__hppa__) || defined(__ia64__) || \
     defined(__mips__) || \
+    defined(__e2k__) || \
     defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__) || \
     defined(_POWER) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \
     defined(__sparc__) || defined(__sparc) || defined(__s390__) || \
diff --git a/Source/WTF/wtf/text/IntegerToStringConversion.h b/Source/WTF/wtf/text/IntegerToStringConversion.h
index c7546675..43c46efe 100644
--- a/Source/WTF/wtf/text/IntegerToStringConversion.h
+++ b/Source/WTF/wtf/text/IntegerToStringConversion.h
@@ -125,6 +125,9 @@ inline unsigned lengthOfIntegerAsString(IntegerType integer)
         return lengthOfIntegerAsStringImpl<typename std::make_unsigned_t<IntegerType>, PositiveNumber>(integer);
     } else
         return lengthOfIntegerAsStringImpl<IntegerType, PositiveNumber>(integer);
+#ifdef __EDG__
+    return 0;
+#endif
 }
 
 } // namespace WTF
diff --git a/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm b/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm
index be6a6dc0..4ee7c4dd 100644
--- a/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm
+++ b/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm
@@ -7749,7 +7749,11 @@ sub GenerateConstructorDefinition
 
             # FIXME: toJSNewlyCreated should return JSObject* instead of JSValue.
             push(@$outputArray, "    auto jsValue = toJSNewlyCreated<${IDLType}>(" . join(", ", @constructionConversionArguments) . ");\n");
+            push(@$outputArray, "#ifdef __EDG__\n");
+            push(@$outputArray, "    if (IsExceptionOr<decltype(object)>)\n");
+            push(@$outputArray, "#else\n");
             push(@$outputArray, "    if constexpr (IsExceptionOr<decltype(object)>)\n");
+            push(@$outputArray, "#endif\n");
             push(@$outputArray, "        RETURN_IF_EXCEPTION(throwScope, { });\n");
             push(@$outputArray, "    setSubclassStructureIfNeeded<${implType}>(lexicalGlobalObject, callFrame, asObject(jsValue));\n");
             push(@$outputArray, "    RETURN_IF_EXCEPTION(throwScope, { });\n");
diff --git a/Source/WebCore/platform/graphics/ColorTypes.h b/Source/WebCore/platform/graphics/ColorTypes.h
index 27cac100..3cffafe0 100644
--- a/Source/WebCore/platform/graphics/ColorTypes.h
+++ b/Source/WebCore/platform/graphics/ColorTypes.h
@@ -283,6 +283,9 @@ template<typename ColorType1, typename ColorType2, bool enabled> inline constexp
 template<typename ColorType1, typename ColorType2> inline constexpr bool IsSameRGBTypeFamilyValue<ColorType1, ColorType2, true> = std::is_same_v<typename ColorType1::Descriptor, typename ColorType2::Descriptor>;
 template<typename ColorType1, typename ColorType2> inline constexpr bool IsSameRGBTypeFamily = IsSameRGBTypeFamilyValue<ColorType1, ColorType2, IsRGBType<ColorType1> && IsRGBType<ColorType2>>;
 
+#define xyzToLinear xyzToLinear = ColorMatrix<3, 3>
+#define linearToXYZ linearToXYZ = ColorMatrix<3, 3>
+
 template<typename T> struct SRGBADescriptor {
     template<TransferFunctionMode Mode> using TransferFunction = SRGBTransferFunction<T, Mode>;
     static constexpr WhitePoint whitePoint = WhitePoint::D65;
@@ -386,6 +389,9 @@ template<typename T> struct Rec2020Descriptor {
     };
 };
 
+#undef xyzToLinear
+#undef linearToXYZ
+
 template<typename T> using Rec2020 = BoundedGammaEncoded<T, Rec2020Descriptor<T>>;
 template<typename T> using LinearRec2020 = BoundedLinearEncoded<T, Rec2020Descriptor<T>>;
 
diff --git a/Source/WebCore/rendering/style/GridArea.h b/Source/WebCore/rendering/style/GridArea.h
index b7ebd1d9..28addb6a 100644
--- a/Source/WebCore/rendering/style/GridArea.h
+++ b/Source/WebCore/rendering/style/GridArea.h
@@ -103,6 +103,9 @@ public:
 
         operator unsigned&() { return value; }
         unsigned operator*() const { return value; }
+#ifdef __EDG__
+        const GridSpanIterator &operator ++() { ++value; return *this; }
+#endif
 
         unsigned value;
     };
diff --git a/Source/WebKit/UIProcess/WebPageProxy.cpp b/Source/WebKit/UIProcess/WebPageProxy.cpp
index 9ee4df74..a3c60cf9 100644
--- a/Source/WebKit/UIProcess/WebPageProxy.cpp
+++ b/Source/WebKit/UIProcess/WebPageProxy.cpp
@@ -5212,19 +5212,19 @@ void WebPageProxy::decidePolicyForNavigationAction(Ref<WebProcessProxy>&& proces
             auto transaction = m_pageLoadState.transaction();
             m_pageLoadState.setTitleFromSafeBrowsingWarning(transaction, safeBrowsingWarning->title());
 
-            m_pageClient->showSafeBrowsingWarning(*safeBrowsingWarning, [this, protectedThis = WTFMove(protectedThis), completionHandler = WTFMove(completionHandler), policyAction] (auto&& result) mutable {
+            m_pageClient->showSafeBrowsingWarning(*safeBrowsingWarning, [self = this, protectedThis = WTFMove(protectedThis), completionHandler = WTFMove(completionHandler), policyAction] (auto&& result) mutable {
 
-                auto transaction = m_pageLoadState.transaction();
-                m_pageLoadState.setTitleFromSafeBrowsingWarning(transaction, { });
+                auto transaction = self->m_pageLoadState.transaction();
+                self->m_pageLoadState.setTitleFromSafeBrowsingWarning(transaction, { });
 
                 switchOn(result, [&] (const URL& url) {
                     completionHandler(PolicyAction::Ignore);
-                    loadRequest({ url });
+                    self->loadRequest({ url });
                 }, [&] (ContinueUnsafeLoad continueUnsafeLoad) {
                     switch (continueUnsafeLoad) {
                     case ContinueUnsafeLoad::No:
-                        if (!hasCommittedAnyProvisionalLoads())
-                            m_uiClient->close(protectedThis.ptr());
+                        if (!self->hasCommittedAnyProvisionalLoads())
+                            self->m_uiClient->close(protectedThis.ptr());
                         completionHandler(PolicyAction::Ignore);
                         break;
                     case ContinueUnsafeLoad::Yes:
-- 
2.17.1

