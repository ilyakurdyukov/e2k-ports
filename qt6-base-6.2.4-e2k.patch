From b1dc9f03d4ce2b3a2c03ec6a5a13cd0b64027c87 Mon Sep 17 00:00:00 2001
From: Ilya Kurdyukov <jpegqs@gmail.com>
Date: Sun, 23 Oct 2022 10:59:50 +0700
Subject: [PATCH] qt6-base-6.2.4 e2k support

using LCC 1.25.23 and -mno-sse4.2
---
 cmake/QtCompilerFlags.cmake                   |  2 +
 config.tests/x86_simd/main.cpp                |  6 +++
 configure.cmake                               |  1 +
 .../double-conversion/utils.h                 |  1 +
 .../qtconcurrentstoredfunctioncall.h          | 39 +++++++++++++++++++
 src/corelib/global/archdetect.cpp             |  2 +
 src/corelib/global/qcompilerdetection.h       | 12 +++++-
 src/corelib/global/qlogging.cpp               |  2 +-
 src/corelib/global/qprocessordetection.h      |  9 +++++
 src/corelib/global/qsimd.cpp                  | 10 ++++-
 src/corelib/global/qsimd.h                    | 11 ++++++
 src/corelib/global/qsimd_p.h                  |  4 +-
 src/corelib/kernel/qmetatype.h                | 22 +++++++++++
 src/corelib/kernel/qmetatype_p.h              |  4 ++
 src/corelib/kernel/qproperty.h                |  2 +-
 src/corelib/text/qstring.cpp                  |  5 +++
 src/corelib/thread/qfuture_impl.h             |  4 ++
 src/corelib/tools/qhash.h                     |  5 +++
 src/corelib/tools/qhashfunctions.h            |  4 ++
 src/corelib/tools/qlist.h                     |  7 ++++
 src/gui/kernel/qplatformintegration.h         |  7 ++++
 src/gui/painting/qdrawhelper.cpp              |  2 +-
 .../platform/unix/qunixnativeinterface.cpp    | 15 +++++++
 .../gl_integrations/xcb_egl/qxcbeglcontext.h  |  3 ++
 .../auto/corelib/text/qlocale/tst_qlocale.cpp |  2 +-
 .../gui/painting/qpainter/tst_qpainter.cpp    |  2 +-
 26 files changed, 173 insertions(+), 10 deletions(-)

diff --git a/cmake/QtCompilerFlags.cmake b/cmake/QtCompilerFlags.cmake
index 0954ba95..6ff53647 100644
--- a/cmake/QtCompilerFlags.cmake
+++ b/cmake/QtCompilerFlags.cmake
@@ -14,6 +14,8 @@ else()
     else()
         list(APPEND _qt_compiler_warning_flags_on -Wall -Wextra)
     endif()
+    # False warnings of this type from EDG frontend are very annoying. 
+    list(APPEND _qt_compiler_warning_flags_on -Wno-return-type)
     list(APPEND _qt_compiler_warning_flags_off -w)
 endif()
 
diff --git a/config.tests/x86_simd/main.cpp b/config.tests/x86_simd/main.cpp
index 0e7ebed8..089b1cd1 100644
--- a/config.tests/x86_simd/main.cpp
+++ b/config.tests/x86_simd/main.cpp
@@ -48,6 +48,12 @@
 #  define attribute_target(x)
 #endif
 
+#if defined(__e2k__) && ( \
+  T(SSE4_2) || T(AVX) || T(AVX2) || \
+  T(F16C) || T(SHANI) || T(RDRND) || T(AESNI))
+#error
+#endif
+
 #if T(SSE2)
 attribute_target("sse2") void test_sse2()
 {
diff --git a/configure.cmake b/configure.cmake
index 251da236..6e679abc 100644
--- a/configure.cmake
+++ b/configure.cmake
@@ -695,6 +695,7 @@ qt_feature("sse2" PRIVATE
     LABEL "SSE2"
     CONDITION ( ( (  TEST_architecture_arch STREQUAL i386 )
         OR ( TEST_architecture_arch STREQUAL x86_64 ) ) AND TEST_subarch_sse2 ) OR QT_FORCE_FEATURE_sse2 OR WASM
+        OR ( TEST_architecture_arch STREQUAL e2k )
     AUTODETECT NOT WASM
 )
 qt_feature_definition("sse2" "QT_COMPILER_SUPPORTS_SSE2" VALUE "1")
diff --git a/src/3rdparty/double-conversion/double-conversion/utils.h b/src/3rdparty/double-conversion/double-conversion/utils.h
index c72c333f..ad55e385 100644
--- a/src/3rdparty/double-conversion/double-conversion/utils.h
+++ b/src/3rdparty/double-conversion/double-conversion/utils.h
@@ -108,6 +108,7 @@ int main(int argc, char** argv) {
     defined(__ARMEL__) || defined(__avr32__) || defined(_M_ARM) || defined(_M_ARM64) || \
     defined(__hppa__) || defined(__ia64__) || \
     defined(__mips__) || \
+    defined(__e2k__) || \
     defined(__nios2__) || defined(__ghs) || \
     defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__) || \
     defined(_POWER) || defined(_ARCH_PPC) || defined(_ARCH_PPC64) || \
diff --git a/src/concurrent/qtconcurrentstoredfunctioncall.h b/src/concurrent/qtconcurrentstoredfunctioncall.h
index 5b2fffde..f3f316d7 100644
--- a/src/concurrent/qtconcurrentstoredfunctioncall.h
+++ b/src/concurrent/qtconcurrentstoredfunctioncall.h
@@ -137,8 +137,47 @@ using InvokeResultType = typename InvokeResult<Function, Args...>::Type;
 template <class ...Types>
 using DecayedTuple = std::tuple<std::decay_t<Types>...>;
 
+#ifdef __EDG__
+template <typename... T>
+struct StoredFunctionCall;
+
+template <class Function>
+struct StoredFunctionCall<Function> : public RunFunctionTaskBase<InvokeResultType<Function>>
+{
+    StoredFunctionCall(DecayedTuple<Function> &&_data)
+        : data(std::move(_data))
+    {}
+
+protected:
+    void runFunctor() override
+    {
+        constexpr auto invoke = [] (std::decay_t<Function> function) -> auto {
+            return std::invoke(function);
+        };
+
+        if constexpr (std::is_void_v<InvokeResultType<Function>>) {
+            std::apply(invoke, std::move(data));
+        } else {
+            auto result = std::apply(invoke, std::move(data));
+
+            using T = InvokeResultType<Function>;
+            if constexpr (std::is_move_constructible_v<T>)
+                this->promise.reportAndMoveResult(std::move(result));
+            else if constexpr (std::is_copy_constructible_v<T>)
+                this->promise.reportResult(result);
+        }
+    }
+
+private:
+    DecayedTuple<Function> data;
+};
+
+template <class Function, class ...Args>
+struct StoredFunctionCall<Function, Args...> : public RunFunctionTaskBase<InvokeResultType<Function, Args...>>
+#else
 template <class Function, class ...Args>
 struct StoredFunctionCall : public RunFunctionTaskBase<InvokeResultType<Function, Args...>>
+#endif
 {
     StoredFunctionCall(DecayedTuple<Function, Args...> &&_data)
         : data(std::move(_data))
diff --git a/src/corelib/global/archdetect.cpp b/src/corelib/global/archdetect.cpp
index b758b232..3fd8bdee 100644
--- a/src/corelib/global/archdetect.cpp
+++ b/src/corelib/global/archdetect.cpp
@@ -71,6 +71,8 @@
 #  define ARCH_PROCESSOR "riscv32"
 #elif defined(Q_PROCESSOR_RISCV_64)
 #  define ARCH_PROCESSOR "riscv64"
+#elif defined(Q_PROCESSOR_E2K)
+#  define ARCH_PROCESSOR "e2k"
 #elif defined(Q_PROCESSOR_S390_X)
 #  define ARCH_PROCESSOR "s390x"
 #elif defined(Q_PROCESSOR_S390)
diff --git a/src/corelib/global/qcompilerdetection.h b/src/corelib/global/qcompilerdetection.h
index 584f1f79..bf2420c7 100644
--- a/src/corelib/global/qcompilerdetection.h
+++ b/src/corelib/global/qcompilerdetection.h
@@ -1290,6 +1290,16 @@
 #  define QT_WARNING_DISABLE_DEPRECATED         QT_WARNING_DISABLE_CLANG("-Wdeprecated-declarations")
 #  define QT_WARNING_DISABLE_FLOAT_COMPARE      QT_WARNING_DISABLE_CLANG("-Wfloat-equal")
 #  define QT_WARNING_DISABLE_INVALID_OFFSETOF   QT_WARNING_DISABLE_CLANG("-Winvalid-offsetof")
+#elif defined(__EDG__)
+#  define QT_WARNING_PUSH
+#  define QT_WARNING_POP                        QT_DO_PRAGMA(diag_default deprecated_entity_with_custom_message)
+#  define QT_WARNING_DISABLE_GCC(text)
+#  define QT_WARNING_DISABLE_CLANG(text)
+#  define QT_WARNING_DISABLE_INTEL(number)
+#  define QT_WARNING_DISABLE_MSVC(number)
+#  define QT_WARNING_DISABLE_DEPRECATED         QT_DO_PRAGMA(diag_suppress deprecated_entity_with_custom_message)
+#  define QT_WARNING_DISABLE_FLOAT_COMPARE
+#  define QT_WARNING_DISABLE_INVALID_OFFSETOF
 #elif defined(Q_CC_GNU) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 406)
 #  define QT_WARNING_PUSH                       QT_DO_PRAGMA(GCC diagnostic push)
 #  define QT_WARNING_POP                        QT_DO_PRAGMA(GCC diagnostic pop)
@@ -1370,7 +1380,7 @@
 /*
     Sanitize compiler feature availability
 */
-#if !defined(Q_PROCESSOR_X86)
+#if !defined(Q_PROCESSOR_X86) && !defined(__e2k__)
 #  undef QT_COMPILER_SUPPORTS_SSE2
 #  undef QT_COMPILER_SUPPORTS_SSE3
 #  undef QT_COMPILER_SUPPORTS_SSSE3
diff --git a/src/corelib/global/qlogging.cpp b/src/corelib/global/qlogging.cpp
index 5d9c5c99..be6ea78f 100644
--- a/src/corelib/global/qlogging.cpp
+++ b/src/corelib/global/qlogging.cpp
@@ -1274,7 +1274,7 @@ void QMessagePattern::setPattern(const QString &pattern)
 // make sure the function has "Message" in the name so the function is removed
 
 #if ((defined(Q_CC_GNU) && defined(QT_COMPILER_SUPPORTS_SIMD_ALWAYS)) || __has_attribute(optimize)) \
-    && !defined(Q_CC_INTEL) && !defined(Q_CC_CLANG)
+    && !defined(Q_CC_INTEL) && !defined(Q_CC_CLANG) && !defined(__EDG__)
 // force skipping the frame pointer, to save the backtrace() function some work
 __attribute__((optimize("omit-frame-pointer")))
 #endif
diff --git a/src/corelib/global/qprocessordetection.h b/src/corelib/global/qprocessordetection.h
index 72cc0b4a..603095ca 100644
--- a/src/corelib/global/qprocessordetection.h
+++ b/src/corelib/global/qprocessordetection.h
@@ -281,6 +281,15 @@
 #  endif
 // Q_BYTE_ORDER not defined, use endianness auto-detection
 
+/*
+    Elbrus 2000 family.
+
+    Elbrus is little-endian.
+*/
+#elif defined(__e2k__)
+#  define Q_PROCESSOR_E2K
+#  define Q_BYTE_ORDER Q_LITTLE_ENDIAN
+
 /*
     RISC-V family, known variants: 32- and 64-bit
 
diff --git a/src/corelib/global/qsimd.cpp b/src/corelib/global/qsimd.cpp
index 025c50b6..4d92b92c 100644
--- a/src/corelib/global/qsimd.cpp
+++ b/src/corelib/global/qsimd.cpp
@@ -113,7 +113,7 @@ static const char features_string[] =
 static const int features_indices[] = {
        0, 1, 6
 };
-#elif defined(Q_PROCESSOR_X86)
+#elif defined(Q_PROCESSOR_X86) || defined(__e2k__)
 #  include "qsimd_x86.cpp"                  // generated by util/x86simdgen
 #else
 static const char features_string[] = "";
@@ -187,7 +187,11 @@ static inline quint64 detectProcessorFeatures()
     return features;
 }
 
-#elif defined(Q_PROCESSOR_X86)
+#elif defined(Q_PROCESSOR_X86) || defined(__e2k__)
+
+#ifdef __e2k__
+#define Q_CC_EMSCRIPTEN
+#endif
 
 #ifdef Q_PROCESSOR_X86_32
 # define PICreg "%%ebx"
@@ -417,8 +421,10 @@ static quint64 detectProcessorFeatures()
         features &= ~AllAVX512;
     }
 
+#ifndef __e2k__
     if (features & CpuFeatureRDRND && !checkRdrndWorks())
         features &= ~(CpuFeatureRDRND | CpuFeatureRDSEED);
+#endif
 
     return features;
 }
diff --git a/src/corelib/global/qsimd.h b/src/corelib/global/qsimd.h
index 5fd34d00..22a9aa41 100644
--- a/src/corelib/global/qsimd.h
+++ b/src/corelib/global/qsimd.h
@@ -113,6 +113,10 @@
 #endif
 #endif
 
+#ifdef __e2k__
+#define Q_PROCESSOR_X86
+#endif
+
 #if defined(Q_PROCESSOR_X86) && defined(__SSE2__)
 #  include <immintrin.h>
 #  define QT_COMPILER_USES_sse2 1
@@ -138,6 +142,13 @@
 #  define QT_COMPILER_USES_sse4_1 -1
 #endif
 
+#ifdef __e2k__
+#undef Q_PROCESSOR_X86
+#undef __SSE4_2__
+#undef __AVX__
+#undef __AVX2__
+#endif
+
 #if defined(Q_PROCESSOR_X86) && defined(__SSE4_2__)
 #  define QT_COMPILER_USES_sse4_2 1
 #else
diff --git a/src/corelib/global/qsimd_p.h b/src/corelib/global/qsimd_p.h
index 118a62e6..e9ad7a46 100644
--- a/src/corelib/global/qsimd_p.h
+++ b/src/corelib/global/qsimd_p.h
@@ -182,7 +182,7 @@
 #  define QT_FUNCTION_TARGET(x)
 #endif
 
-#ifdef Q_PROCESSOR_X86
+#if defined(Q_PROCESSOR_X86) || defined(__e2k__)
 /* -- x86 intrinsic support -- */
 
 #  if defined(Q_CC_MSVC) && (defined(_M_X64) || _M_IX86_FP >= 2)
@@ -323,7 +323,7 @@ inline uint8_t vaddv_u8(uint8x8_t v8)
 
 QT_BEGIN_NAMESPACE
 
-#ifndef Q_PROCESSOR_X86
+#if !defined Q_PROCESSOR_X86 & !defined(__e2k__)
 enum CPUFeatures {
 #if defined(Q_PROCESSOR_ARM)
     CpuFeatureNEON          = 2,
diff --git a/src/corelib/kernel/qmetatype.h b/src/corelib/kernel/qmetatype.h
index e20118f4..8930a540 100644
--- a/src/corelib/kernel/qmetatype.h
+++ b/src/corelib/kernel/qmetatype.h
@@ -1225,6 +1225,7 @@ int qRegisterNormalizedMetaType(const QT_PREPEND_NAMESPACE(QByteArray) &normaliz
     const QMetaType metaType = QMetaType::fromType<T>();
     const int id = metaType.id();
 
+    /* The EDG frontend has problems with the next two lines. */
     QtPrivate::SequentialContainerTransformationHelper<T>::registerConverter();
     QtPrivate::SequentialContainerTransformationHelper<T>::registerMutableView();
     QtPrivate::AssociativeContainerTransformationHelper<T>::registerConverter();
@@ -1605,10 +1606,21 @@ namespace QtPrivate {
 template<typename From>
 struct QSequentialIterableConvertFunctor
 {
+#ifdef __EDG__
+    /* Somehow this fixes an internal compiler error
+       with SequentialContainerTransformationHelper
+       from the Q_DECLARE_METATYPE macro. */
+    static auto get() {
+        return [](const From &f) {
+            return QIterable<QMetaSequence>(QMetaSequence::fromContainer<From>(), &f);
+        };
+    }
+#else
     QIterable<QMetaSequence> operator()(const From &f) const
     {
         return QIterable<QMetaSequence>(QMetaSequence::fromContainer<From>(), &f);
     }
+#endif
 };
 
 template<typename From>
@@ -1627,7 +1639,11 @@ struct SequentialValueTypeIsMetaType<T, true>
     {
         const QMetaType to = QMetaType::fromType<QIterable<QMetaSequence>>();
         if (!QMetaType::hasRegisteredConverterFunction(QMetaType::fromType<T>(), to)) {
+#ifdef __EDG__
+            auto o = QSequentialIterableConvertFunctor<T>::get();
+#else
             QSequentialIterableConvertFunctor<T> o;
+#endif
             return QMetaType::registerConverter<T, QIterable<QMetaSequence>>(o);
         }
         return true;
@@ -1955,6 +1971,8 @@ public:
             begin++;
         while (begin != end && is_space(*(end - 1)))
             end--;
+        // because in qmetatype.cpp: {nullptr, 0, QMetaType::UnknownType}
+        if (begin == end) return len;
 
         // Convert 'char const *' into 'const char *'. Start at index 1,
         // not 0, because 'const char *' is already OK.
@@ -2392,7 +2410,11 @@ template<typename T, typename ODR_VIOLATION_PREVENTER>
 struct is_complete_helper
 {
     template<typename U>
+#ifdef __EDG__
+    static auto check(U *) -> std::integral_constant<bool, sizeof(U) ? true : false>;
+#else
     static auto check(U *) -> std::integral_constant<bool, sizeof(U) != 0>;
+#endif
     static auto check(...) -> std::false_type;
     using type = decltype(check(static_cast<T *>(nullptr)));
 };
diff --git a/src/corelib/kernel/qmetatype_p.h b/src/corelib/kernel/qmetatype_p.h
index d3b3138a..7693032f 100644
--- a/src/corelib/kernel/qmetatype_p.h
+++ b/src/corelib/kernel/qmetatype_p.h
@@ -221,7 +221,11 @@ template<> struct TypeDefinition<QIcon> { static const bool IsAvailable = false;
 #endif
 
 template<typename T>
+#ifdef __EDG__
+constexpr const QT_PREPEND_NAMESPACE(QtPrivate::QMetaTypeInterface) *getInterfaceFromType()
+#else
 static const QT_PREPEND_NAMESPACE(QtPrivate::QMetaTypeInterface) *getInterfaceFromType()
+#endif
 {
     if constexpr (QtMetaTypePrivate::TypeDefinition<T>::IsAvailable) {
         return &QT_PREPEND_NAMESPACE(QtPrivate::QMetaTypeInterfaceWrapper)<T>::metaType;
diff --git a/src/corelib/kernel/qproperty.h b/src/corelib/kernel/qproperty.h
index 39528706..1686abd1 100644
--- a/src/corelib/kernel/qproperty.h
+++ b/src/corelib/kernel/qproperty.h
@@ -58,7 +58,7 @@
 #endif
 #endif
 
-#if !defined(QT_PROPERTY_COLLECT_BINDING_LOCATION) && __has_include(<experimental/source_location>) && __cplusplus >= 201703L && !defined(Q_CLANG_QDOC)
+#if !defined(QT_PROPERTY_COLLECT_BINDING_LOCATION) && __has_include(<experimental/source_location>) && __cplusplus >= 201703L && !defined(Q_CLANG_QDOC) && !defined(__EDG__)
 #include <experimental/source_location>
 #if defined(__cpp_lib_experimental_source_location)
 #define QT_SOURCE_LOCATION_NAMESPACE std::experimental
diff --git a/src/corelib/text/qstring.cpp b/src/corelib/text/qstring.cpp
index 58426442..3d4ea82d 100644
--- a/src/corelib/text/qstring.cpp
+++ b/src/corelib/text/qstring.cpp
@@ -139,6 +139,11 @@ extern "C" void qt_fromlatin1_mips_asm_unroll8 (char16_t*, const char*, uint);
 extern "C" void qt_toLatin1_mips_dsp_asm(uchar *dst, const char16_t *src, int length);
 #endif
 
+#ifdef __e2k__
+// LCC can do better without
+#undef __SSE2__
+#endif
+
 // internal
 qsizetype qFindStringBoyerMoore(QStringView haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs);
 static inline qsizetype qFindChar(QStringView str, QChar ch, qsizetype from, Qt::CaseSensitivity cs) noexcept;
diff --git a/src/corelib/thread/qfuture_impl.h b/src/corelib/thread/qfuture_impl.h
index 57c4fb39..b924e8bc 100644
--- a/src/corelib/thread/qfuture_impl.h
+++ b/src/corelib/thread/qfuture_impl.h
@@ -826,7 +826,11 @@ namespace QtFuture {
 template<class Signal>
 using ArgsType = typename QtPrivate::ArgResolver<Signal>::AllArgs;
 
+#ifdef __EDG__
+template<class Sender, class Signal>
+#else
 template<class Sender, class Signal, typename = QtPrivate::EnableIfInvocable<Sender, Signal>>
+#endif
 static QFuture<ArgsType<Signal>> connect(Sender *sender, Signal signal)
 {
     using ArgsType = ArgsType<Signal>;
diff --git a/src/corelib/tools/qhash.h b/src/corelib/tools/qhash.h
index 3190a2e3..f9cc147e 100644
--- a/src/corelib/tools/qhash.h
+++ b/src/corelib/tools/qhash.h
@@ -65,6 +65,11 @@ namespace QHashPrivate {
 template <typename T, typename = void>
 constexpr inline bool HasQHashOverload = false;
 
+#ifdef __EDG__
+template <typename T1, typename T2>
+constexpr inline bool HasQHashOverload<std::pair<T1, T2>> = true;
+#endif
+
 template <typename T>
 constexpr inline bool HasQHashOverload<T, std::enable_if_t<
     std::is_convertible_v<decltype(qHash(std::declval<const T &>(), std::declval<size_t>())), size_t>
diff --git a/src/corelib/tools/qhashfunctions.h b/src/corelib/tools/qhashfunctions.h
index a3e16006..f7792d99 100644
--- a/src/corelib/tools/qhashfunctions.h
+++ b/src/corelib/tools/qhashfunctions.h
@@ -234,11 +234,15 @@ struct QHashCombineCommutative
 };
 
 template <typename... T>
+#ifdef __EDG__
+using QHashMultiReturnType = size_t;
+#else
 using QHashMultiReturnType = decltype(
     std::declval< std::enable_if_t<(sizeof...(T) > 0)> >(),
     (qHash(std::declval<const T &>()), ...),
     size_t{}
 );
+#endif
 
 // workaround for a MSVC ICE,
 // https://developercommunity.visualstudio.com/content/problem/996540/internal-compiler-error-on-msvc-1924-when-doing-sf.html
diff --git a/src/corelib/tools/qlist.h b/src/corelib/tools/qlist.h
index 2dda8db4..b56ff42e 100644
--- a/src/corelib/tools/qlist.h
+++ b/src/corelib/tools/qlist.h
@@ -293,7 +293,14 @@ public:
     }
 
     // This constructor is here for compatibility with QStringList in Qt 5, that has a QStringList(const QString &) constructor
+#ifdef __EDG__
+    template<typename X, typename Y>
+    struct edg_fix : std::integral_constant<bool,
+         std::is_same_v<X, QString> && std::is_convertible_v<Y, QString>> {};
+    template<typename String, std::enable_if_t<edg_fix<T, String>::value, bool> = true>
+#else
     template<typename String, typename = std::enable_if_t<std::is_same_v<T, QString> && std::is_convertible_v<String, QString>>>
+#endif
     inline explicit QList(const String &str)
     { append(str); }
 
diff --git a/src/gui/kernel/qplatformintegration.h b/src/gui/kernel/qplatformintegration.h
index 75b942f9..532ee80d 100644
--- a/src/gui/kernel/qplatformintegration.h
+++ b/src/gui/kernel/qplatformintegration.h
@@ -83,6 +83,13 @@ class QVulkanInstance;
 
 namespace QNativeInterface::Private {
 
+#ifdef __EDG__
+#define QInterfaceProxy_EDG(X, T, func) \
+    if (auto *iface = dynamic_cast<T*>(X)) \
+        return iface->func; \
+    return nullptr
+#endif
+
 template <typename R, typename I, auto func, typename... Args>
 struct QInterfaceProxyImp
 {
diff --git a/src/gui/painting/qdrawhelper.cpp b/src/gui/painting/qdrawhelper.cpp
index f50d4f63..3aa9ec6d 100644
--- a/src/gui/painting/qdrawhelper.cpp
+++ b/src/gui/painting/qdrawhelper.cpp
@@ -6144,7 +6144,7 @@ void qt_memfill64(quint64 *dest, quint64 color, qsizetype count)
 }
 #endif
 
-#if defined(QT_COMPILER_SUPPORTS_SSSE3) && defined(Q_CC_GNU) && !defined(Q_CC_INTEL) && !defined(Q_CC_CLANG)
+#if defined(QT_COMPILER_SUPPORTS_SSSE3) && defined(Q_CC_GNU) && !defined(Q_CC_INTEL) && !defined(Q_CC_CLANG) && !defined(__e2k__)
 __attribute__((optimize("no-tree-vectorize")))
 #endif
 void qt_memfill24(quint24 *dest, quint24 color, qsizetype count)
diff --git a/src/gui/platform/unix/qunixnativeinterface.cpp b/src/gui/platform/unix/qunixnativeinterface.cpp
index e010c390..e1a7f3bf 100644
--- a/src/gui/platform/unix/qunixnativeinterface.cpp
+++ b/src/gui/platform/unix/qunixnativeinterface.cpp
@@ -102,14 +102,24 @@ QT_DEFINE_PRIVATE_NATIVE_INTERFACE(QGLXIntegration);
 
 QOpenGLContext *QNativeInterface::QGLXContext::fromNative(GLXContext configBasedContext, QOpenGLContext *shareContext)
 {
+#ifdef __EDG__
+    QInterfaceProxy_EDG(QGuiApplicationPrivate::platformIntegration(),
+        QGLXIntegration, createOpenGLContext(configBasedContext, nullptr, shareContext));
+#else
     return QGuiApplicationPrivate::platformIntegration()->call<
         &QGLXIntegration::createOpenGLContext>(configBasedContext, nullptr, shareContext);
+#endif
 }
 
 QOpenGLContext *QNativeInterface::QGLXContext::fromNative(GLXContext visualBasedContext, void *visualInfo, QOpenGLContext *shareContext)
 {
+#ifdef __EDG__
+    QInterfaceProxy_EDG(QGuiApplicationPrivate::platformIntegration(),
+        QGLXIntegration, createOpenGLContext(visualBasedContext, visualInfo, shareContext));
+#else
     return QGuiApplicationPrivate::platformIntegration()->call<
         &QGLXIntegration::createOpenGLContext>(visualBasedContext, visualInfo, shareContext);
+#endif
 }
 #endif // QT_CONFIG(xcb_glx_plugin)
 
@@ -150,8 +160,13 @@ QT_DEFINE_PRIVATE_NATIVE_INTERFACE(QEGLIntegration);
 
 QOpenGLContext *QNativeInterface::QEGLContext::fromNative(EGLContext context, EGLDisplay display, QOpenGLContext *shareContext)
 {
+#ifdef __EDG__
+    QInterfaceProxy_EDG(QGuiApplicationPrivate::platformIntegration(),
+        QEGLIntegration, createOpenGLContext(context, display, shareContext));
+#else
     return QGuiApplicationPrivate::platformIntegration()->call<
         &QEGLIntegration::createOpenGLContext>(context, display, shareContext);
+#endif
 }
 #endif // QT_CONFIG(egl)
 
diff --git a/src/plugins/platforms/xcb/gl_integrations/xcb_egl/qxcbeglcontext.h b/src/plugins/platforms/xcb/gl_integrations/xcb_egl/qxcbeglcontext.h
index 3c3e497e..cd8a08ff 100644
--- a/src/plugins/platforms/xcb/gl_integrations/xcb_egl/qxcbeglcontext.h
+++ b/src/plugins/platforms/xcb/gl_integrations/xcb_egl/qxcbeglcontext.h
@@ -50,6 +50,9 @@ class QXcbEglContext : public QEGLPlatformContext
 {
 public:
     using QEGLPlatformContext::QEGLPlatformContext;
+#ifdef __EDG__
+    QXcbEglContext() {}
+#endif
     QXcbEglContext(const QSurfaceFormat &glFormat, QPlatformOpenGLContext *share, EGLDisplay display)
         : QEGLPlatformContext(glFormat, share, display, nullptr)
     {
diff --git a/tests/auto/corelib/text/qlocale/tst_qlocale.cpp b/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
index bf68f69d..999068d3 100644
--- a/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
+++ b/tests/auto/corelib/text/qlocale/tst_qlocale.cpp
@@ -46,7 +46,7 @@
 #include <qnumeric.h>
 #include "../../../../shared/localechange.h"
 
-#if defined(Q_OS_LINUX) && !defined(__UCLIBC__)
+#if defined(Q_OS_LINUX) && !defined(__UCLIBC__) && !defined(__e2k__)
 #    define QT_USE_FENV
 #endif
 
diff --git a/tests/auto/gui/painting/qpainter/tst_qpainter.cpp b/tests/auto/gui/painting/qpainter/tst_qpainter.cpp
index 45490ef8..d4bc9bbf 100644
--- a/tests/auto/gui/painting/qpainter/tst_qpainter.cpp
+++ b/tests/auto/gui/painting/qpainter/tst_qpainter.cpp
@@ -2846,7 +2846,7 @@ void tst_QPainter::monoImages()
     }
 }
 
-#if !defined(Q_OS_AIX) && !defined(Q_CC_MSVC) && !defined(Q_OS_SOLARIS) && !defined(__UCLIBC__) && !defined(Q_OS_INTEGRITY)
+#if !defined(Q_OS_AIX) && !defined(Q_CC_MSVC) && !defined(Q_OS_SOLARIS) && !defined(__UCLIBC__) && !defined(Q_OS_INTEGRITY) && !defined(__e2k__)
 #include <fenv.h>
 
 static const QString fpeExceptionString(int exception)
-- 
2.34.1

